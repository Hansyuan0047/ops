# Linux 系统性能监控

## CPU 性能监控

**CPU 性能监控** 主要用来分析和跟踪 CPU 的使用情况。通过对 CPU 负载、各核使用情况以及实时监控，系统管理员可以了解系统是否存在性能瓶颈，优化系统负载，确保 CPU 的高效运行。

### 查看CPU核心数量

```
lscpu
```

![image-20250217084448838](./assets/image-20250217084448838.png)

- **Architecture**: x86_64
    - 表示系统的架构类型，**x86_64** 是指 64 位架构，支持更大的内存和更高的计算能力。
- **CPU op-mode(s)**: 32-bit, 64-bit
    - 表示该 CPU 支持 32 位和 64 位两种操作模式。64 位模式可以处理更大的内存空间。
- **Byte Order**: Little Endian
    - 表示字节序，**Little Endian** 是指低位字节存储在低地址，适用于大多数现代处理器（如 Intel 和 AMD）。
- **CPU(s)**: 80
    - 表示系统中逻辑 CPU 核心的总数，包括物理核心和每个物理核心的超线程。这里有 80 个逻辑 CPU 核心。
- **On-line CPU(s) list**: 0-79
    - 显示当前启用的 CPU 核心范围，从 CPU 0 到 CPU 79，表示所有逻辑核心都处于活动状态。
- **Thread(s) per core**: 2
    - 表示每个物理核心支持 2 个线程，即启用了超线程技术，每个核心可以并行处理 2 个任务。
- **Core(s) per socket**: 20
    - 每个 CPU 插槽（socket）包含 20 个物理核心，表示每个 CPU 芯片上有 20 个独立的处理核心。

### top命令使用

`top` 支持根据不同字段进行排序，按下相应的字母键即可进行排序：

- **`P`**：按照 CPU 使用率排序。
- **`M`**：按照内存使用排序。
- **`T`**：按照时间排序，显示运行时间最长的进程。
- **`N`**：按照进程 ID 排序。

- **`c`**：切换显示命令行及其参数。

![image-20250217085947113](./assets/image-20250217085947113.png)

下面是 `top` 命令输出的解析：

1. **系统概览**

```
top - 08:59:29 up 87 days, 15:44,  1 user,  load average: 19.53, 19.95, 19.49
```

- **时间**：当前时间是 `08:59:29`。
- **系统运行时长**：系统已经运行了 `87` 天 `15` 小时 `44` 分钟。
- **用户**：当前系统中有 `1` 个用户登录。
- **负载平均值**：`19.53`（1分钟）、`19.95`（5分钟）、`19.49`（15分钟）。负载平均值表示系统运行的压力，值越高表示系统越繁忙。这里显示的值接近 `CPU 核心数`，可能意味着系统负载较高。

2. **任务信息**

```
Tasks: 1821 total,   3 running, 1326 sleeping,   0 stopped,   0 zombie
```

- **总任务数**：共有 `1821` 个任务（进程）。
- **正在运行的任务**：有 `3` 个进程正在运行。
- **休眠中的任务**：有 `1326` 个进程在休眠（即等待资源或事件）。
- **停止和僵尸进程**：没有停止进程和僵尸进程。

3. **CPU 使用情况**

```
%Cpu(s):  9.0 us,  2.4 sy,  0.0 ni, 84.8 id,  3.5 wa,  0.0 hi,  0.3 si,  0.0 st
```

- **%us**（用户空间）：`9.0%` 的 CPU 时间用于执行用户进程。
- **%sy**（系统空间）：`2.4%` 的 CPU 时间用于执行内核进程。
- **%ni**（优先级调整）：`0.0%`，表示优先级（nice）调整的进程占用的 CPU 时间。
- **%id**（空闲时间）：`84.8%` 的 CPU 时间处于空闲状态。
- **%wa**（等待 I/O）：`3.5%` 的 CPU 时间在等待磁盘 I/O 操作。
- **%hi**（硬件中断）：`0.0%` 的 CPU 时间在处理硬件中断。
- **%si**（软件中断）：`0.3%` 的 CPU 时间在处理软件中断。
- **%st**（虚拟化偷取时间）：`0.0%`，表示虚拟机环境中的 CPU 偷取时间。

4. **内存使用情况**

```
KiB Mem : 26358908+total, 10638072 free, 15585318+used, 97097824 buff/cache
```

- **总内存**：系统总内存为 `26358908 KiB`（约 25.1 GB）。
- **空闲内存**：空闲内存为 `10638072 KiB`（约 10.1 GB）。
- **已用内存**：已使用内存为 `15585318 KiB`（约 14.9 GB）。
- **缓存内存**：`97097824 KiB`（约 92.7 GB）的内存用于缓存和缓冲区。

5. **交换区（Swap）使用情况**

```
KiB Swap:        0 total,        0 free,        0 used. 99981616 avail Mem
```

- **总交换区**：没有配置交换区（`0`）。
- **可用内存**：`99981616 KiB`（约 95.3 GB）是可用于新进程的内存。

6. **进程信息**

```
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
  3515 root      20   0 9758688 629696  30080 S 169.0  0.2 165802:23 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/...
```

- **PID**：进程 ID `3515`。
- **USER**：进程所属用户是 `root`。
- **PR**（优先级）：`20`（默认优先级）。
- **NI**（Nice 值）：`0`（表示没有调整优先级）。
- **VIRT**：进程占用的虚拟内存为 `9758688 KiB`。
- **RES**：进程占用的常驻内存为 `629696 KiB`。
- **SHR**：进程共享的内存为 `30080 KiB`。
- **S**（状态）：进程处于 `S`（睡眠）状态。
- **%CPU**：进程使用了 `169.0%` 的 CPU，表示该进程的 CPU 使用量非常高，可能是多线程或多核处理。
- **%MEM**：进程使用了 `0.2%` 的总内存。
- **TIME+**：进程总共消耗了 `165802:23` 的 CPU 时间。
- **COMMAND**：该进程的命令行是 `/usr/bin/kubelet`，这通常是 Kubernetes 节点上的 Kubelet 进程，负责管理容器和节点。



## 内存性能

**内存性能** 监控主要用于查看系统内存的使用情况，包括物理内存的使用、Swap（交换分区）的使用情况，以及缓存和缓冲区的使用。通过对这些数据的分析，管理员可以判断系统内存是否存在瓶颈，及时优化内存资源，避免出现性能问题。

### 内存使用情况

**`free` 命令**可以显示内存的使用情况，`-h` 选项表示以易读的格式显示（例如，MB、GB）。

示例输出（`free -h`）：

```
total        used        free      shared  buff/cache   available
Mem:           8.0Gi       3.2Gi       2.0Gi       1.0Gi       2.8Gi       3.9Gi
Swap:          2.0Gi       0.0Gi       2.0Gi
```

- `total`：表示总内存大小
- `used`：已用内存
- `free`：空闲内存
- `buff/cache`：缓存和缓冲区占用的内存
- `available`：可用内存，表示实际可用于分配的内存量

## 硬盘性能

**硬盘性能** 监控主要用于分析磁盘的使用情况、I/O 性能以及文件系统的状态。通过监控磁盘的使用率、读写性能和文件系统信息，系统管理员可以发现硬盘瓶颈，优化磁盘资源管理。

### 磁盘使用情况

查看磁盘分区的使用情况，包括磁盘空间的总量、已用空间、可用空间以及文件系统的挂载情况：

- **命令**：`df -h` 或 `du -sh`
- **主要指标**：
    - 每个分区的总空间、已用空间和可用空间
    - 文件系统的类型
    - 挂载点（磁盘分区的挂载位置）

**`df -h` 命令**可以查看各分区的使用情况，`-h` 参数会以易读的格式（例如 MB、GB）显示输出。

示例输出（`df -h`）：

```
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1        100G   45G   55G  45% /
/dev/sdb1        500G  250G  250G  50% /data
```

- `Size`：表示文件系统的总大小
- `Used`：已使用的空间
- `Avail`：剩余的可用空间
- `Use%`：已使用的百分比
- `Mounted on`：文件系统的挂载点

**`du -sh` 命令**用于查看特定目录或文件的磁盘使用情况，`-s` 表示汇总结果，`-h` 表示以易读的格式显示。

示例输出（`du -sh /data`）：

```
250G    /data
```

这里显示 `/data` 目录的总大小为 250GB。

### 磁盘 I/O 性能

要监控磁盘的 I/O 性能，查看磁盘的读取和写入速率、等待时间等数据：

**`iostat` 命令**是用于监控系统 I/O 性能的常用工具，特别适用于查看磁盘的 I/O 活动。

```
# iostat -x 2
Device            r/s     w/s    rKB/s   wKB/s    avgrq-sz  avgqu-sz   await  svctm  %util
sda               15.0    10.0    150.0   100.0    40.0      1.0        10.0   3.0   5.0
sdb               8.0     5.0     80.0    50.0     35.0      0.5        12.0   4.0   2.0
```

- **`rrqm/s`**：每秒合并的读取请求数（read requests merged per second）。
- **`wrqm/s`**：每秒合并的写入请求数（write requests merged per second）。
- **`r/s`**：每秒读取请求数。
- **`w/s`**：每秒写入请求数。
- **`rkB/s`**：每秒读取的字节数（KB）。
- **`wkB/s`**：每秒写入的字节数（KB）。
- **`avgrq-sz`**：平均请求大小（字节）。
- **`avgqu-sz`**：I/O 请求队列的平均长度。
- **`await`**：I/O 请求的平均等待时间（毫秒）。
- **`r_await`**：读取请求的平均等待时间（毫秒）。
- **`w_await`**：写入请求的平均等待时间（毫秒）。
- **`svctm`**：I/O 请求的平均服务时间（毫秒）。
- **`%util`**：设备的利用率，表示磁盘的繁忙程度（百分比）。



## **网络性能**

**网络性能** 监控主要用于检查网络接口的状态、流量、延迟和吞吐量等。通过这些监控工具，可以及时发现网络瓶颈、延迟或带宽问题，从而优化网络配置和提高网络性能。

### **网络接口信息**

查看网络接口的详细信息，包括 IP 地址、MAC 地址、网络接口状态等：

- **命令**：`ifconfig` 或 `ip addr show`
- **主要指标**：
    - 网络接口的状态（如 UP、DOWN）
    - 配置的 IP 地址、网络掩码和广播地址
    - 接口的接收和发送字节数

**`ifconfig` 命令**可以显示网络接口的详细信息。虽然 `ifconfig` 是传统命令，但在现代系统中，它仍然广泛使用，特别是在较旧的 Linux 发行版上。

示例输出（`ifconfig`）：

```
eth0      Link encap:Ethernet  HWaddr 00:1a:2b:3c:4d:5e
          inet addr:192.168.1.100  Bcast:192.168.1.255  Mask:255.255.255.0
          inet6 addr: fe80::21a:2bff:fe3c:4d5e/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1053234 errors:0 dropped:0 overruns:0 frame:0
          TX packets:82342 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:125094567 (125.0 MB)  TX bytes:35467890 (35.4 MB)
```

解释：

- `inet addr`：显示网络接口的 IPv4 地址
- `RX packets` 和 `TX packets`：接收和发送的数据包数量
- `RX bytes` 和 `TX bytes`：接收和发送的字节数

**`ip addr show` 命令**是 `ifconfig` 的现代替代品，能够提供更多的信息和更细致的控制。

示例输出（`ip addr show`）：

```
2: eth0: <BROADCAST,RUNNING,MULTICAST> mtu 1500 qdisc fq_codel state UP qlen 1000
    inet 192.168.1.100/24 brd 192.168.1.255 scope global eth0
       valid_lft forever preferred_lft forever
```

其中，`inet` 后面显示的是接口的 IP 地址，`state UP` 表示接口状态为 UP。

### **网络流量统计**

查看系统网络端口的监听情况，尤其是哪些端口正在监听服务，并显示相关进程信息：

- **命令**：`netstat -tulnp` 或 `ss -tulnp`

- 主要指标

    ：

    - 当前监听的端口和协议（TCP 或 UDP）
    - 监听的地址和端口（IP 地址和端口号）
    - 监听的服务和进程 ID（PID）

#### **`netstat -tulnp` 命令**

`netstat` 显示当前系统中所有正在监听的 TCP 和 UDP 端口，并显示每个端口的状态和对应的进程 ID（PID）。

**示例输出（`netstat -tulnp`）**：

```
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1234/sshd
tcp6       0      0 :::80                   :::*                    LISTEN      5678/httpd
udp        0      0 0.0.0.0:123             0.0.0.0:*               LISTEN      2345/ntpd
```

- **`Proto`**：协议（TCP 或 UDP）
- **`Local Address`**：本地地址和端口
- **`Foreign Address`**：外部地址（监听时为空）
- **`State`**：端口的状态（如 `LISTEN`）
- **`PID/Program name`**：进程 ID 和进程名称，显示正在监听端口的进程

#### **`ss -tulnp` 命令**

`ss` 是 `netstat` 的更现代替代品，速度更快，输出也更简洁，同时提供了进程信息。

**示例输出（`ss -tulnp`）**：

```
State       Recv-Q      Send-Q            Local Address:Port               Peer Address:Port       PID/Program name
LISTEN      0           128               *:22                               *:*                     1234/sshd
LISTEN      0           128               :::80                              :::*                    5678/httpd
LISTEN      0           128               *:123                              *:*                     2345/ntpd
```

- **`State`**：端口的状态（如 `LISTEN`）
- **`Local Address:Port`**：本地地址和端口
- **`Peer Address:Port`**：远程地址和端口（监听时为空）
- **`PID/Program name`**：进程 ID 和进程名称，显示正在监听端口的进程

`ss` 命令显示的信息与 `netstat` 类似，但提供了更快速和更简洁的输出。

### **实时网络流量**

用于实时查看网络流量，包括带宽使用情况、入站和出站的数据包信息。以下是常用的工具及其用法。

- `nload`：图形化显示入站和出站流量，适合快速查看当前网络带宽使用情况。
- `iftop`：实时显示网络连接和带宽使用情况，适合监控主机与主机之间的流量。
- `vnstat`：长期流量监控工具，基于数据库，适合查看网络接口的历史流量数据。

#### **1. `nload` - 实时流量监控**

`nload` 是一个简单且直观的工具，用于实时查看网络接口的流量。它会显示入站（RX）和出站（TX）流量，且有图形化的进度条表示流量波动。

**安装命令**：

- 对于 CentOS/RHEL 系统：

    ```
    sudo yum install nload
    ```

- 对于 Ubuntu/Debian 系统：

    ```
    sudo apt-get install nload
    ```

**命令使用**：

```
nload [interface]
```

- `[interface]`：指定要监控的网络接口，例如 `eth0`、`wlan0` 等。

**示例输出**：

```
Incoming:
+--------------------------------------------------+
|   #####                                         |
|   #####                                         |
|   #####                                         |
+--------------------------------------------------+
1500 KB/s 0 KB/s

Outgoing:
+--------------------------------------------------+
|   ###                                           |
|   ###                                           |
|   ###                                           |
+--------------------------------------------------+
500 KB/s 0 KB/s
```

**输出解释**：

- **Incoming**：显示入站（RX）流量的图形化进度条以及具体数值（例如 `1500 KB/s`）。
- **Outgoing**：显示出站（TX）流量的图形化进度条以及具体数值（例如 `500 KB/s`）。

#### **2. `iftop` - 实时流量监控**

`iftop` 用于显示实时网络流量，尤其适合查看特定主机或端口的进出流量。与 `top` 命令类似，它显示每个连接的带宽使用情况。

**安装命令**：

- 对于 CentOS/RHEL 系统：

    ```
    sudo yum install iftop
    ```

- 对于 Ubuntu/Debian 系统：

    ```
    sudo apt-get install iftop
    ```

**命令使用**：

```
iftop -i [interface]
```

- `[interface]`：指定要监控的网络接口，例如 `eth0`、`wlan0` 等。

**示例输出**：

```
1.50Kb  0.00Kb  1.00Kb  -> 192.168.1.100:22      192.168.1.200:53821
2.50Kb  0.00Kb  2.00Kb  -> 192.168.1.100:80      192.168.1.150:43012
```

**输出解释**：

- **流量**：每行显示了流入（接收）和流出（发送）数据的速度，例如 `1.50Kb` 和 `2.50Kb`。
- **连接信息**：显示源 IP 地址和端口、目标 IP 地址和端口。例如：`192.168.1.100:22 -> 192.168.1.200:53821`，表示从源 IP `192.168.1.100` 的端口 22 连接到目标 IP `192.168.1.200` 的端口 53821。

#### **3. `vnstat` - 网络流量监控（基于数据库）**

`vnstat` 是一个基于数据库的网络流量监控工具，适用于长期流量监控，它会记录网络接口的流量并提供统计信息。

**安装命令**：

- 对于 CentOS/RHEL 系统：

    ```
    sudo yum install vnstat
    ```

- 对于 Ubuntu/Debian 系统：

    ```
    sudo apt-get install vnstat
    ```

**命令使用**：

```
vnstat -l -i [interface]
```

- `-l`：实时显示流量统计。
- `-i [interface]`：指定要监控的网络接口，例如 `eth0`。

**示例输出**：

```
Network device: eth0
  2025-02-17 08:45:09   RX:  500 kB  TX:  300 kB  (3.5 kB/s  2.1 kB/s)
  2025-02-17 08:45:19   RX:  550 kB  TX:  350 kB  (4.0 kB/s  2.5 kB/s)
```

**输出解释**：

- **RX（接收流量）**：显示接收的数据量及速率，例如 `500 kB` 和 `3.5 kB/s`。
- **TX（发送流量）**：显示发送的数据量及速率，例如 `300 kB` 和 `2.1 kB/s`。
- **时间**：显示更新时间，确保你能够追踪流量的变化。



### **网络延迟与吞吐量**

通过 `ping`、`traceroute` 和 `iperf3` 等命令来测量网络的延迟、吞吐量和路径。以下是这些命令的详细说明及输出示例。

- `ping`：用于检查目标主机是否可达，并测量网络延迟（RTT）。
- `traceroute`：用于追踪数据包的路由路径，显示每跳的延迟和路由信息，帮助分析网络瓶颈。
- `iperf3`：用于带宽测试，测量客户端和服务器之间的网络吞吐量，适合评估网络性能。

#### **1. `ping` - 测量网络延迟**

`ping` 命令用于检查目标主机是否可达，并测量网络延迟（即响应时间）。它发送 ICMP 回显请求并接收响应，从而确定网络的延迟情况。

**命令使用**：

```
ping [目标主机]
```

- `[目标主机]`：可以是 IP 地址或者域名，例如 `192.168.1.1` 或 `google.com`。

**示例输出**：

```
PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.
64 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=0.022 ms
64 bytes from 192.168.1.1: icmp_seq=2 ttl=64 time=0.020 ms
```

**输出解释**：

- `icmp_seq`：ICMP 请求的序列号。
- `ttl`：生存时间（Time To Live），表示数据包经过的路由器数目。
- `time`：往返时间（Round Trip Time，RTT），即网络的延迟时间，单位为毫秒（ms）。

#### **2. `traceroute` - 路由跟踪**

`traceroute` 命令用于追踪数据包从源主机到目标主机的路由路径，帮助诊断网络中的跳数和延迟。它逐跳显示数据包经过的每个路由器，并给出每跳的延迟。

**安装命令**：

- 对于 CentOS/RHEL 系统：

    ```
    sudo yum install traceroute
    ```

- 对于 Ubuntu/Debian 系统：

    ```
    sudo apt-get install traceroute
    ```

**命令使用**：

```
traceroute [目标主机]
```

- `[目标主机]`：目标主机的 IP 地址或域名。

**示例输出**：

```
traceroute to 8.8.8.8 (8.8.8.8), 30 hops max, 60 byte packets
 1  192.168.1.1 (192.168.1.1)  0.078 ms  0.091 ms  0.105 ms
 2  10.0.0.1 (10.0.0.1)  5.123 ms  5.067 ms  5.016 ms
 3  8.8.8.8 (8.8.8.8)  15.678 ms  15.545 ms  15.555 ms
```

**输出解释**：

- 每一行代表一次路由跳跃（hop）。
- 每一跳会显示目标的 IP 地址或域名、该跳的延迟（单位：ms）。
- 例如，第 1 跳是从 `192.168.1.1` 发出的延迟为 `0.078 ms`，第 2 跳到 `10.0.0.1` 的延迟为 `5.123 ms`，依此类推。

#### **3. `iperf3` - 网络带宽测试**

`iperf3` 命令用于测试网络吞吐量，常用于测试客户端和服务器之间的网络带宽。它通过客户端和服务器之间的数据传输来测试网络的性能。

**安装命令**：

- 对于 CentOS/RHEL 系统：

    ```
    sudo yum install iperf3
    ```

- 对于 Ubuntu/Debian 系统：

    ```
    sudo apt-get install iperf3
    ```

**命令使用**：

1. **在服务器端启动 `iperf3`**：

    ```
    iperf3 -s
    ```

    - `-s` 表示服务器模式，监听来自客户端的连接。

2. **在客户端进行测试**：

    ```
    iperf3 -c [服务器 IP 地址]
    ```

    - `-c [服务器 IP 地址]` 表示连接到指定的服务器。

**示例输出（客户端）**：

```
[ ID] Interval       Transfer     Bandwidth
[  5]  0.0-10.0 sec   1.20 GBytes  1.02 Gbits/sec
```

**输出解释**：

- `Interval`：测试的时间段。
- `Transfer`：传输的数据量。
- `Bandwidth`：测试期间的平均带宽。



## 进程与资源消耗

在 Linux 系统中，管理和监控进程是非常重要的一部分工作。通过命令行工具，你可以查看进程的状态、资源消耗情况，甚至终止不需要的进程。`ps` 和 `kill` 是两个常用的命令，下面我们将深入讲解这两个命令的用法和细节。

------

### `ps` 命令：查看进程的详细信息

`ps`（process status）命令用于显示当前系统中正在运行的进程信息。它是了解系统进程状况的一个重要工具，能够提供非常详细的信息，包括进程的状态、资源占用情况等。

**常用选项和用法**：

- **`ps aux`**：

    - `a`：显示所有用户的进程。
    - `u`：显示进程的所属用户。
    - `x`：包括没有控制终端的进程（例如后台进程）。

    **示例**：

    ```bash
    ps aux
    ```

    输出示例：

    ```bash
    USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root      1234  0.2  1.1  23456  7890 ?        S    08:00   0:20 /usr/bin/python3
    user1     5678  1.5  2.3  45678 12345 tty1     R    09:00   2:30 /bin/bash
    ```

    **解释**：

    - `USER`：进程所属的用户。
    - `PID`：进程 ID。
    - `%CPU`：进程占用的 CPU 百分比。
    - `%MEM`：进程占用的内存百分比。
    - `VSZ`：进程使用的虚拟内存，单位为 KB。
    - `RSS`：进程占用的物理内存，单位为 KB。
    - `TTY`：进程关联的终端设备。
    - `STAT`：进程的状态（例如：S = 休眠，R = 运行中）。
    - `START`：进程启动的时间。
    - `TIME`：进程使用的 CPU 时间。
    - `COMMAND`：执行的命令。

- **`ps -ef`**：

    - 显示所有进程的详细信息，使用标准格式。`e` 表示显示所有进程，`f` 表示以树形结构显示进程。

    **示例**：

    ```bash
    ps -ef
    ```

    输出示例：

    ```bash
    UID        PID  PPID  C STIME TTY      TIME CMD
    root       1    0     0 09:00 ?        00:00:05 /sbin/init
    root     1234  1     0 09:05 ?        00:00:03 /usr/bin/python3
    user1    5678  1234  1 09:06 tty1     00:00:01 /bin/bash
    ```

    **解释**：

    - `UID`：进程的用户 ID。
    - `PID`：进程 ID。
    - `PPID`：父进程 ID。
    - `C`：进程的 CPU 占用率。
    - `STIME`：进程启动的时间。
    - `TTY`：进程所在的终端。
    - `TIME`：该进程使用的 CPU 时间。
    - `CMD`：执行的命令。

- **`ps -p <pid>`**：

    - 显示指定进程 ID（PID）的信息。非常有用当你想查看某个特定进程的资源占用情况时。

    **示例**：

    ```bash
    ps -p 1234
    ```

    输出示例：

    ```bash
    PID TTY      STAT   TIME   COMMAND
    1234 ?        S      00:00:05 /usr/bin/python3
    ```

**组合选项使用**：

- **`ps aux --sort=-%mem`**：按内存占用从大到小排序。

- **`ps aux --sort=-%cpu`**：按 CPU 占用从大到小排序。

    **示例**：

    ```bash
    ps aux --sort=-%cpu
    ```

    输出示例：

    ```bash
    USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root      1234 50.5  1.2  23456  7890 ?        S    08:00   0:30 /usr/bin/python3
    user1     5678 20.0  2.0  45678 12345 tty1     R    09:00   2:00 /bin/bash
    ```

### `kill` 命令：终止进程

`kill` 命令用于发送信号到进程。常见的用途是终止进程或发送其他信号来控制进程的行为。默认情况下，`kill` 会发送 `SIGTERM` 信号，要求进程优雅地退出。如果进程没有响应，可以使用 `SIGKILL` 强制结束进程。

**常用信号**：

- **`SIGTERM (15)`**：请求进程正常终止。这是默认信号，进程可以选择捕获该信号并进行必要的清理。
- **`SIGKILL (9)`**：强制终止进程。进程无法捕获或忽略该信号，因此进程会被立即终止。

**常见用法**：

- **`kill <pid>`**：发送 `SIGTERM` 信号请求进程退出。

    **示例**：

    ```bash
    kill 1234
    ```

    该命令将尝试正常终止进程 1234。

- **`kill -9 <pid>`**：发送 `SIGKILL` 信号强制终止进程。即使进程没有响应，它也会立即被杀死。

    **示例**：

    ```bash
    kill -9 1234
    ```

- **`killall <process_name>`**：根据进程名称（COMMAND）终止所有匹配的进程。

    **示例**：

    ```bash
    killall python3
    ```

    该命令将终止所有名为 `python3` 的进程。

- **`kill -0 <pid>`**：不发送信号，仅检查指定进程是否存在。该命令不会终止进程，但它可以用于检查进程是否仍然在运行。

    **示例**：

    ```
    kill -0 1234
    ```

    如果进程 `1234` 存在且可访问，该命令不会有任何输出。如果进程不存在或没有权限访问该进程，会返回错误信息。

**查看进程的资源消耗**：

在终止进程之前，你可以使用 `ps` 或 `top` 查看进程的 CPU 和内存占用情况，帮助你决定是否需要结束某个进程。

- 使用 `ps aux | grep <process_name>` 查找进程的 PID。
- 使用 `top -p <pid>` 实时查看进程的资源使用情况。



